[
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "winsound",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winsound",
        "description": "winsound",
        "detail": "winsound",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "gradio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gradio",
        "description": "gradio",
        "detail": "gradio",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "autocast",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "StableDiffusionPipeline",
        "importPath": "diffusers",
        "description": "diffusers",
        "isExtraImport": true,
        "detail": "diffusers",
        "documentation": {}
    },
    {
        "label": "load_dataset",
        "importPath": "datasets",
        "description": "datasets",
        "isExtraImport": true,
        "detail": "datasets",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "Note",
        "kind": 6,
        "importPath": "12_ton_technik",
        "description": "12_ton_technik",
        "peekOfCode": "class Note:\n    pitch: str # pitch name (C, C#, D, D#, E, F, F#, G, G#, A, A#, H)\n    octave: int # octave number (0-8)\n    duration: int # duration in 16th notes (1-16)\n    def __init__(self, pitch: str, octave: int = 4, duration: int = 4):\n        self.pitch = pitch\n        self.octave = octave\n        self.duration = duration\n    def __str__(self):\n        return f\"{self.pitch}{self.octave}:{self.duration}\"",
        "detail": "12_ton_technik",
        "documentation": {}
    },
    {
        "label": "note_lookup",
        "kind": 5,
        "importPath": "12_ton_technik",
        "description": "12_ton_technik",
        "peekOfCode": "note_lookup = {\n    \"C\": 261.63,\n    \"C#\": 277.18,\n    \"D\": 293.66,\n    \"D#\": 311.13,\n    \"E\": 329.63,\n    \"F\": 349.23,\n    \"F#\": 369.99,\n    \"G\": 392.00,\n    \"G#\": 415.30,",
        "detail": "12_ton_technik",
        "documentation": {}
    },
    {
        "label": "notes",
        "kind": 5,
        "importPath": "12_ton_technik",
        "description": "12_ton_technik",
        "peekOfCode": "notes = []\nunused_notes = list(note_lookup.keys())\nfor i in range(12):\n    pitch = random.choice(unused_notes)\n    unused_notes.remove(pitch)\n    octave = random.choice([3, 4, 5])\n    duration = random.choice([1, 2, 4, 8])\n    notes.append(Note(pitch, octave, duration))\nfor note in notes:\n    print(note)",
        "detail": "12_ton_technik",
        "documentation": {}
    },
    {
        "label": "unused_notes",
        "kind": 5,
        "importPath": "12_ton_technik",
        "description": "12_ton_technik",
        "peekOfCode": "unused_notes = list(note_lookup.keys())\nfor i in range(12):\n    pitch = random.choice(unused_notes)\n    unused_notes.remove(pitch)\n    octave = random.choice([3, 4, 5])\n    duration = random.choice([1, 2, 4, 8])\n    notes.append(Note(pitch, octave, duration))\nfor note in notes:\n    print(note)\n    note.play()",
        "detail": "12_ton_technik",
        "documentation": {}
    },
    {
        "label": "float_to_char",
        "kind": 2,
        "importPath": "arr_to_str",
        "description": "arr_to_str",
        "peekOfCode": "def float_to_char(val: float) -> str:\n    if val > 1.0 or val < -1.0:\n        raise ValueError(\"Value must be between -1.0 and 1.0\")\n    # remap from [-1.0, 1.0] to [0, 255]\n    val = int((val + 1) * 127.5)\n    return chr(val)\ndef char_to_float(val: str) -> float:\n    # remap from [0, 255] to [-1.0, 1.0]\n    return (ord(val) / 127.5) - 1\ndef arr_to_str(arr: list[float]) -> str:",
        "detail": "arr_to_str",
        "documentation": {}
    },
    {
        "label": "char_to_float",
        "kind": 2,
        "importPath": "arr_to_str",
        "description": "arr_to_str",
        "peekOfCode": "def char_to_float(val: str) -> float:\n    # remap from [0, 255] to [-1.0, 1.0]\n    return (ord(val) / 127.5) - 1\ndef arr_to_str(arr: list[float]) -> str:\n    out_str = \"\"\n    for val in arr:\n        out_str += float_to_char(val)\n    return out_str\ndef str_to_arr(in_str: str) -> list[float]:\n    out_arr = []",
        "detail": "arr_to_str",
        "documentation": {}
    },
    {
        "label": "arr_to_str",
        "kind": 2,
        "importPath": "arr_to_str",
        "description": "arr_to_str",
        "peekOfCode": "def arr_to_str(arr: list[float]) -> str:\n    out_str = \"\"\n    for val in arr:\n        out_str += float_to_char(val)\n    return out_str\ndef str_to_arr(in_str: str) -> list[float]:\n    out_arr = []\n    for val in in_str:\n        out_arr.append(char_to_float(val))\n    return out_arr",
        "detail": "arr_to_str",
        "documentation": {}
    },
    {
        "label": "str_to_arr",
        "kind": 2,
        "importPath": "arr_to_str",
        "description": "arr_to_str",
        "peekOfCode": "def str_to_arr(in_str: str) -> list[float]:\n    out_arr = []\n    for val in in_str:\n        out_arr.append(char_to_float(val))\n    return out_arr\ndb = sqlite3.connect(\"test.db\")\ncursor = db.cursor()\ncmd = \"CREATE TABLE IF NOT EXISTS test (id INTEGER PRIMARY KEY, data TEXT)\"\ncursor.execute(cmd)\n# insert some data",
        "detail": "arr_to_str",
        "documentation": {}
    },
    {
        "label": "db",
        "kind": 5,
        "importPath": "arr_to_str",
        "description": "arr_to_str",
        "peekOfCode": "db = sqlite3.connect(\"test.db\")\ncursor = db.cursor()\ncmd = \"CREATE TABLE IF NOT EXISTS test (id INTEGER PRIMARY KEY, data TEXT)\"\ncursor.execute(cmd)\n# insert some data\nfor _ in tqdm(range(100_000)):\n    data = [random.uniform(-1, 1) for _ in range(1024)]\n    cursor.execute(\"INSERT INTO test (data) VALUES (?)\", (arr_to_str(data),))\ndb.commit()",
        "detail": "arr_to_str",
        "documentation": {}
    },
    {
        "label": "cursor",
        "kind": 5,
        "importPath": "arr_to_str",
        "description": "arr_to_str",
        "peekOfCode": "cursor = db.cursor()\ncmd = \"CREATE TABLE IF NOT EXISTS test (id INTEGER PRIMARY KEY, data TEXT)\"\ncursor.execute(cmd)\n# insert some data\nfor _ in tqdm(range(100_000)):\n    data = [random.uniform(-1, 1) for _ in range(1024)]\n    cursor.execute(\"INSERT INTO test (data) VALUES (?)\", (arr_to_str(data),))\ndb.commit()",
        "detail": "arr_to_str",
        "documentation": {}
    },
    {
        "label": "cmd",
        "kind": 5,
        "importPath": "arr_to_str",
        "description": "arr_to_str",
        "peekOfCode": "cmd = \"CREATE TABLE IF NOT EXISTS test (id INTEGER PRIMARY KEY, data TEXT)\"\ncursor.execute(cmd)\n# insert some data\nfor _ in tqdm(range(100_000)):\n    data = [random.uniform(-1, 1) for _ in range(1024)]\n    cursor.execute(\"INSERT INTO test (data) VALUES (?)\", (arr_to_str(data),))\ndb.commit()",
        "detail": "arr_to_str",
        "documentation": {}
    },
    {
        "label": "generate_image",
        "kind": 2,
        "importPath": "gradio_sdxl_turbo",
        "description": "gradio_sdxl_turbo",
        "peekOfCode": "def generate_image(\n    prompt: str, \n    samples: int,\n    steps: int,\n    scale: float,\n    seed: int\n) -> Image.Image:\n    generator = pipe.generator(device=device).manual_seed(seed)\n    with autocast(\"cuda\"):\n        image_list = generator(prompt, samples=samples, steps=steps, scale=scale)",
        "detail": "gradio_sdxl_turbo",
        "documentation": {}
    },
    {
        "label": "model_id",
        "kind": 5,
        "importPath": "gradio_sdxl_turbo",
        "description": "gradio_sdxl_turbo",
        "peekOfCode": "model_id = \"stabilityai/sdxl-turbo\"\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npipe = StableDiffusionPipeline.from_pretrained(model_id).to(device)\ndef generate_image(\n    prompt: str, \n    samples: int,\n    steps: int,\n    scale: float,\n    seed: int\n) -> Image.Image:",
        "detail": "gradio_sdxl_turbo",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "gradio_sdxl_turbo",
        "description": "gradio_sdxl_turbo",
        "peekOfCode": "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\npipe = StableDiffusionPipeline.from_pretrained(model_id).to(device)\ndef generate_image(\n    prompt: str, \n    samples: int,\n    steps: int,\n    scale: float,\n    seed: int\n) -> Image.Image:\n    generator = pipe.generator(device=device).manual_seed(seed)",
        "detail": "gradio_sdxl_turbo",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 5,
        "importPath": "gradio_sdxl_turbo",
        "description": "gradio_sdxl_turbo",
        "peekOfCode": "pipe = StableDiffusionPipeline.from_pretrained(model_id).to(device)\ndef generate_image(\n    prompt: str, \n    samples: int,\n    steps: int,\n    scale: float,\n    seed: int\n) -> Image.Image:\n    generator = pipe.generator(device=device).manual_seed(seed)\n    with autocast(\"cuda\"):",
        "detail": "gradio_sdxl_turbo",
        "documentation": {}
    },
    {
        "label": "iface",
        "kind": 5,
        "importPath": "gradio_sdxl_turbo",
        "description": "gradio_sdxl_turbo",
        "peekOfCode": "iface = gr.Interface(\n    fn = generate_image,\n    inputs = [\n        gr.Textbox(placeholder=\"Enter a prompt...\"),\n        gr.Slider(label=\"Samples\", minimum=1, maximum=10, value=1, step=1),\n        gr.Number(label=\"Steps\", value=4, step=1),\n        gr.Slider(label=\"Scale\", minimum=0, maximum=14, value=7, step=1),\n        gr.Number(label=\"Seed\", value=0, step=1)\n    ],\n    outputs = gr.Image(label=\"Generated Image\"),",
        "detail": "gradio_sdxl_turbo",
        "documentation": {}
    }
]